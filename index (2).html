<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dining Philosophers – Monitor Solution</title>
  <style>
    :root {
      --bg-main: #181818;
      --bg-box: #232323;
      --accent: #32b8c6;
      --danger: #e57373;
      --warn: #fbc02d;
      --info: #32b8c6;
      --border: #282828;
      --mono: 'JetBrains Mono', 'Fira Mono', 'Menlo', monospace;
      --ui: 'Inter', Arial, sans-serif;
      --input-bg: #151617;
      --input-bd: #32b8c688;
      --legend-bg: #191B1D;
    }
    html, body { height: 100%; }
    body {
      background: var(--bg-main);
      color: #e0e0e0;
      font-family: var(--ui);
      margin: 0;
      min-height: 100vh;
      padding: 0;
    }
    header {
      text-align: center;
      margin-bottom: 18px;
      padding: 24px 0 18px 0;
      border-bottom: 1px solid var(--border);
    }
    h1 { font-size: 2rem; letter-spacing: -.01em; }
    .subtitle { color: #aaa; font-size: 1rem; margin-top: 4px;}
    .main-grid {
      display: grid;
      grid-template-columns: 2fr 1fr;
      grid-template-rows: 1fr auto;
      gap: 30px 32px;
      max-width: 1200px;
      margin: 48px auto 0 auto;
      align-items: start;
      position: relative;
    }
    .diagram-box {
      grid-column: 1/2; grid-row: 1/2;
      background: var(--bg-box);
      border-radius: 14px;
      box-shadow: 0 2px 8px #00000036;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 510px;
      min-width: 480px;
      border: 2px solid #222;
      box-sizing: border-box;
    }
    .side-col {
      display: flex;
      flex-direction: column;
      height: 510px;
      min-width: 360px;
      grid-column: 2/3; grid-row: 1/2;
    }
    .controls-box {
      background: var(--bg-box);
      border-radius: 14px 14px 0 0;
      flex: 0 0 245px;
      box-shadow: 0 2px 8px #00000036;
      display: flex;
      flex-direction: column;
      border: 2px solid #222;
      border-bottom: none;
      padding: 26px 24px 20px 24px;
      justify-content: flex-start;
      box-sizing: border-box;
    }
    .controls-group { margin-bottom: 14px; }
    .controls-inline-fields {
      display: flex;
      gap: 12px;
      align-items: flex-end;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    .field-group {
      display: flex;
      flex-direction: column;
      flex: 1 1 105px;
      min-width: 105px;
      max-width: 155px;
    }
    .controls-inline-fields label {
      font-size: .98em;
      color: #b9b9b9;
      margin-bottom: 6px;
      font-weight: 500;
    }
    .controls-inline-fields input {
      background: var(--input-bg);
      border: 1.5px solid var(--input-bd);
      color: #e0e0e0;
      border-radius: 5px;
      padding: 7px 10px;
      width: 100%;
      font-size: 16px;
      transition: border-color .16s;
      box-sizing: border-box;
    }
    .controls-inline-fields input:focus {
      border-color: var(--accent);
      outline: none;
    }
    .button-group {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px; margin-bottom: 9px; width: 100%;
    }
    .step-controls {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px; width: 100%; margin-bottom: 10px;
    }
    button {
      background-color: var(--accent);
      color: #181818;
      padding: 15px 0;
      border: none;
      border-radius: 7px;
      font-weight: 650;
      cursor: pointer;
      font-size: 19px;
      width: 100%;
      transition: background .16s;
      margin-bottom: 0;
    }
    button.secondary { background: #35393b; color: #fafafa; }
    button:disabled { opacity: .48; cursor: not-allowed; }
    .status-box {
      background: #111217;
      border-radius: 7px;
      padding: 13px 14px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0;
      font-family: var(--mono);
      font-size: 1.04em;
      margin-bottom: 2px;
      margin-top: 18px;
      min-height: 48px;
      align-items: center;
      width: 100%;
      box-sizing: border-box;
    }
    .status-item { display: flex; flex-direction: column; align-items: center; }
    .status-label { font-size: .93em; color: #9da2a6; }
    .status-value { font-size: 1.08em; font-weight: 700; padding-top: 4px; }
    .status-value.completed { color: #8aff6a; }
    .status-value.running { color:  var(--accent); }
    .status-value.ready { color: #fbc02d; }
    .log-spacer { height: 16px; }
    .log-box {
      background: var(--bg-box);
      border-radius: 0 0 14px 14px;
      flex: 1 1 0;
      box-shadow: 0 2px 8px #00000036;
      border: 2px solid #222;
      font-family: var(--mono);
      font-size: 0.99em;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      min-height: 0; height: 0;
      padding: 0;
      overflow: hidden;
    }
    .log-header {
      background: #232323;
      border-radius: 0;
      padding: 14px 22px 8px 22px;
      font-family: var(--ui); font-size: 1.12em; font-weight: 600;
      border-bottom: 1px solid var(--border);
      flex: 0 0 auto;
    }
    .log-container {
      background: #131313;
      border-radius: 0 0 12px 12px;
      padding: 13px 16px;
      flex: 1 1 auto;
      min-height: 60px;
      max-height: none;
      overflow-y: auto;
      border: none;
    }
    .log-entry.current { color: var(--accent); font-weight: 700; }
    .legend-bar {
      grid-column: 1 / 3;
      grid-row: 2/3;
      background: var(--legend-bg);
      border-radius: 14px;
      border: 2px solid #222;
      padding: 14px 40px;
      display: flex;
      gap: 38px;
      font-size: 1.03em;
      align-items: center;
      justify-content: flex-start;
      width: 100%;
      min-width: 650px;
      max-width: 1200px;
      margin: 0 auto;
      box-sizing: border-box;
    }
    .legend-entry { display: flex; align-items: center; gap: 12px; font-weight: 500;}
    .legend-think { background: var(--danger); width: 22px; height: 22px; border-radius: 6px;}
    .legend-hungry { background: var(--warn); width: 22px; height: 22px; border-radius: 6px;}
    .legend-eat { background: var(--accent); width: 22px; height: 22px; border-radius: 6px;}
    .legend-chop { background: #626c71; width: 22px; height: 22px; border-radius: 6px;}
    @media(max-width:1200px) {
      .main-grid { grid-template-columns: 1fr 1fr; max-width: 99vw;}
      .diagram-box { min-width: 260px; }
      .side-col, .legend-bar { width: 94vw; }
      .legend-bar { min-width: 0; max-width: 99vw;}
    }
    @media(max-width:900px) {
      .main-grid { grid-template-columns: 1fr; grid-template-rows: auto auto auto auto; }
      .diagram-box, .side-col, .legend-bar { width: 96vw; margin: 0 auto;}
      .legend-bar { min-width: 0; max-width: none;}
      .diagram-box, .side-col { min-height:360px;height:auto;}
      .field-group { min-width: 70px; max-width: 100vw;}
    }
  </style>
</head>
<body>
<header>
  <h1>Dining Philosophers Problem</h1>
  <div class="subtitle">Monitor-Based Synchronization Solution</div>
</header>
<div class="main-grid">
  <div class="diagram-box">
    <canvas id="simulationCanvas" width="520" height="520"></canvas>
  </div>
  <div class="side-col">
    <div class="controls-box">
      <div class="controls-group button-group">
        <button id="startBtn">Start</button>
        <button id="resetBtn" class="secondary">Reset</button>
      </div>
      <div class="controls-group step-controls">
        <button id="stepBackBtn" class="secondary">← Previous</button>
        <button id="stepForwardBtn" class="secondary">Next →</button>
      </div>
      <div class="controls-group controls-inline-fields">
        <div class="field-group">
          <label for="thinkTime">Think Time (ms)</label>
          <input type="number" id="thinkTime" value="1000" min="100">
        </div>
        <div class="field-group">
          <label for="eatTime">Eat Time (ms)</label>
          <input type="number" id="eatTime" value="1500" min="100">
        </div>
      </div>
      <div class="status-box">
        <div class="status-item">
          <div class="status-label">Current Step</div>
          <div class="status-value" id="currentStep">0</div>
        </div>
        <div class="status-item">
          <div class="status-label">Total Steps</div>
          <div class="status-value" id="totalSteps">0</div>
        </div>
        <div class="status-item">
          <div class="status-label">Simulation</div>
          <div class="status-value ready" id="simState">Ready</div>
        </div>
      </div>
    </div>
    <div class="log-spacer"></div>
    <div class="log-box">
      <div class="log-header">Execution Log</div>
      <div class="log-container" id="logContainer"></div>
    </div>
  </div>
  <div class="legend-bar">
    <div class="legend-entry"><span class="legend-think"></span>Thinking</div>
    <div class="legend-entry"><span class="legend-hungry"></span>Hungry</div>
    <div class="legend-entry"><span class="legend-eat"></span>Eating</div>
    <div class="legend-entry"><span class="legend-chop"></span>Chopsticks in use</div>
  </div>
</div>
<script>
const canvas = document.getElementById('simulationCanvas');
const ctx = canvas.getContext('2d');
const centerX = canvas.width / 2;
const centerY = canvas.height / 2;
const radius = 160;
const THINKING = 0, HUNGRY = 1, EATING = 2;
const stateNames = ['THINKING', 'HUNGRY', 'EATING'];
const stateColors = ['#e57373', '#fbc02d', '#32b8c6'];
function rightChopstick(i) { return (i + 1) % 5; }
function leftChopstick(i)  { return i; }
function adjChopsticks(i) { return [i, (i + 4) % 5]; }
class DiningPhilosophersMonitor {
  constructor() {
    this.state = [THINKING, THINKING, THINKING, THINKING, THINKING];
    this.chopsticks = [true, true, true, true, true];
  }
  canEat(i) {
    const [left, right] = adjChopsticks(i);
    return this.state[i] === HUNGRY && this.chopsticks[left] && this.chopsticks[right];
  }
  test(i) {
    const [left, right] = adjChopsticks(i);
    if (this.canEat(i)) {
      this.state[i] = EATING;
      this.chopsticks[left] = false;
      this.chopsticks[right] = false;
      return true;
    }
    return false;
  }
  pickupChopsticks(i) {
    this.state[i] = HUNGRY;
    const [left, right] = adjChopsticks(i);
    let detail = '';
    if (this.chopsticks[left] && this.chopsticks[right]) {
      this.test(i);
      detail = `Picked up C${left} & C${right}; now EATING`;
    } else if (!this.chopsticks[left] && !this.chopsticks[right]) {
      detail = `Waiting (both chopsticks C${left}, C${right} in use) (HUNGRY)`;
    } else if (!this.chopsticks[left]) {
      detail = `Picked up only C${right}, waiting for C${left} (HUNGRY)`;
    } else {
      detail = `Picked up only C${left}, waiting for C${right} (HUNGRY)`;
    }
    return `P${i}: ${detail}`;
  }
  putdownChopsticks(i) {
    const [left, right] = adjChopsticks(i);
    this.state[i] = THINKING;
    this.chopsticks[left] = true;
    this.chopsticks[right] = true;
    this.test((i + 4) % 5);
    this.test((i + 1) % 5);
    return `P${i}: Released C${left} & C${right}, now THINKING`;
  }
}
let monitor = new DiningPhilosophersMonitor();
let executionSteps = [];
let currentStepIndex = -1;
let isSimulating = false;
const startBtn = document.getElementById('startBtn');
const resetBtn = document.getElementById('resetBtn');
const stepBackBtn = document.getElementById('stepBackBtn');
const stepForwardBtn = document.getElementById('stepForwardBtn');
const thinkTimeInput = document.getElementById('thinkTime');
const eatTimeInput = document.getElementById('eatTime');
const currentStepDisplay = document.getElementById('currentStep');
const totalStepsDisplay = document.getElementById('totalSteps');
const simStateDisplay = document.getElementById('simState');
const logContainer = document.getElementById('logContainer');
function generateSimulationSteps() {
  executionSteps = [];
  const tempMonitor = new DiningPhilosophersMonitor();
  const sequence = [
    {philosopher: 0, action: 'pickup'},
    {philosopher: 2, action: 'pickup'},
    {philosopher: 4, action: 'pickup'},
    {philosopher: 1, action: 'pickup'},
    {philosopher: 3, action: 'pickup'},
    {philosopher: 0, action: 'putdown'},
    {philosopher: 1, action: 'pickup'},
    {philosopher: 2, action: 'putdown'},
    {philosopher: 3, action: 'pickup'},
    {philosopher: 4, action: 'putdown'},
    {philosopher: 1, action: 'putdown'},
    {philosopher: 3, action: 'putdown'},
  ];
  executionSteps.push({
    state: [...tempMonitor.state],
    chopsticks: [...tempMonitor.chopsticks],
    log: 'Initial state: All philosophers thinking'
  });
  sequence.forEach(({philosopher, action}) => {
    if (action === 'pickup') {
      const logMsg = tempMonitor.pickupChopsticks(philosopher);
      executionSteps.push({
        state: [...tempMonitor.state],
        chopsticks: [...tempMonitor.chopsticks],
        log: logMsg
      });
    } else {
      const logMsg = tempMonitor.putdownChopsticks(philosopher);
      executionSteps.push({
        state: [...tempMonitor.state],
        chopsticks: [...tempMonitor.chopsticks],
        log: logMsg
      });
    }
  });
  totalStepsDisplay.textContent = executionSteps.length - 1;
}
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const step = executionSteps[currentStepIndex] || executionSteps[0];
  for(let i=0; i<5; i++) {
    const angle = (i * 72 - 90) * Math.PI / 180;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    ctx.beginPath();
    ctx.arc(x, y, 37, 0, 2*Math.PI);
    ctx.fillStyle = stateColors[step.state[i]];
    ctx.fill();
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = '#232323';
    ctx.font = '600 16px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`P${i}`, x, y);
    ctx.fillStyle = '#eeeeee';
    ctx.font = '500 12px sans-serif';
    ctx.fillText(stateNames[step.state[i]], x, y+48);
  }
  for(let i=0; i<5; i++) {
    const angle = (i * 72 - 54) * Math.PI / 180;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    ctx.beginPath();
    ctx.arc(x, y, 12, 0, 2*Math.PI);
    ctx.fillStyle = step.chopsticks[i] ? '#626c71' : '#32b8c6';
    ctx.fill();
    ctx.strokeStyle = '#222';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = '#232323';
    ctx.font = '600 10px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`C${i}`, x, y-2);
  }
}
function updateLog() {
  logContainer.innerHTML = '';
  executionSteps.forEach((step, idx) => {
    const entry = document.createElement('div');
    entry.className = 'log-entry' + (idx === currentStepIndex ? ' current' : '');
    entry.textContent = `[Step ${idx}] ${step.log}`;
    logContainer.appendChild(entry);
  });
  if(currentStepIndex >= 0) {
    const currentEntry = logContainer.children[currentStepIndex];
    if(currentEntry) currentEntry.scrollIntoView({behavior:'smooth', block:'nearest'});
  }
}
function updateStatusPanel() {
  currentStepDisplay.textContent = currentStepIndex;
  simStateDisplay.classList.remove('completed', 'ready', 'running');
  if (!isSimulating && currentStepIndex === executionSteps.length-1) {
    simStateDisplay.classList.add('completed');
    simStateDisplay.textContent = 'Completed';
  }
  else if (isSimulating) {
    simStateDisplay.classList.add('running');
    simStateDisplay.textContent = 'Running';
  }
  else {
    simStateDisplay.classList.add('ready');
    simStateDisplay.textContent = 'Ready';
  }
}
function stepForward() {
  if (currentStepIndex < executionSteps.length - 1) {
    currentStepIndex++;
    draw();
    updateLog();
    updateStatusPanel();
    updateButtonStates();
  }
}
function stepBackward() {
  if (currentStepIndex > 0) {
    currentStepIndex--;
    draw();
    updateLog();
    updateStatusPanel();
    updateButtonStates();
  }
}
function updateButtonStates() {
  stepBackBtn.disabled = currentStepIndex <= 0;
  stepForwardBtn.disabled = currentStepIndex >= executionSteps.length - 1;
}
let simInterval = null;
startBtn.addEventListener('click', () => {
  if (isSimulating) return;
  generateSimulationSteps();
  currentStepIndex = 0;
  draw(); updateLog();
  updateButtonStates();
  isSimulating = true;
  updateStatusPanel();
  startBtn.disabled = true;
  const thinkTime = parseInt(thinkTimeInput.value);
  const eatTime = parseInt(eatTimeInput.value);
  const stepDelay = (thinkTime + eatTime) / 2;
  simInterval = setInterval(() => {
    if(currentStepIndex < executionSteps.length-1) {
      stepForward();
    } else {
      clearInterval(simInterval);
      isSimulating = false;
      updateStatusPanel();
      startBtn.disabled = false;
    }
  }, stepDelay);
});
resetBtn.addEventListener('click', () => {
  if(simInterval) clearInterval(simInterval);
  monitor = new DiningPhilosophersMonitor();
  executionSteps = [];
  currentStepIndex = -1;
  isSimulating = false;
  startBtn.disabled = false;
  generateSimulationSteps();
  currentStepIndex = 0;
  draw(); updateLog(); updateButtonStates(); updateStatusPanel();
});
stepForwardBtn.addEventListener('click', stepForward);
stepBackBtn.addEventListener('click', stepBackward);
generateSimulationSteps();
currentStepIndex = 0;
draw();
updateLog();
updateButtonStates();
updateStatusPanel();
</script>
</body>
</html>
